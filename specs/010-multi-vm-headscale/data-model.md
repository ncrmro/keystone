# Data Model: Multi-VM Headscale Connectivity Testing

**Feature**: 010-multi-vm-headscale
**Date**: 2025-11-10

This document defines the data entities, their relationships, and state transitions for the Headscale mesh network testing infrastructure.

---

## Entity Overview

The system consists of five primary entities that model the mesh network infrastructure:

```
┌──────────────────────┐
│ Headscale Server     │
│  - manages nodes     │
│  - issues WG keys    │
│  - provides DNS      │
└──────────┬───────────┘
           │
           │ registers
           │
    ┌──────▼─────────────┐
    │  VM Node           │◄────┐
    │  - hostname        │     │
    │  - mesh IP         │     │ encrypted tunnel
    │  - WG public key   │     │ (WireGuard)
    │  - status          │     │
    └────────────────────┘     │
           │                   │
           │ authenticated via │
           │                   │
    ┌──────▼─────────────┐     │
    │ PreAuth Key        │     │
    │  - token           │     │
    │  - expiration      │     │
    │  - reusable        │     │
    └────────────────────┘     │
                               │
    ┌──────────────────────────┘
    │ WireGuard Tunnel
    │  - peer A
    │  - peer B
    │  - encryption keys
    └────────────────────
           │
           │ resolves to
           │
    ┌──────▼─────────────┐
    │ DNS Record         │
    │  - hostname        │
    │  - mesh IP         │
    │  - base domain     │
    └────────────────────┘
```

---

## Entity Definitions

### 1. Headscale Control Server

**Description**: Central coordination service managing node registration, WireGuard key distribution, and DNS resolution. Acts as the control plane for the mesh network.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `server_url` | String (URL) | Required, must be reachable by clients | Public endpoint for client registration (e.g., http://headscale.example.com:8080) |
| `listen_addr` | String (IP:Port) | Required | Address/port for server to bind (e.g., 0.0.0.0:8080) |
| `db_type` | Enum | Required, one of: `sqlite3`, `postgres` | Database backend type (sqlite3 recommended) |
| `db_path` | String (Path) | Required if db_type=sqlite3 | Path to SQLite database file |
| `ip_prefixes` | List[CIDR] | Required | IP ranges allocated to mesh nodes (e.g., ["100.64.0.0/10"]) |
| `base_domain` | String (Domain) | Required, must differ from server_url domain | Base domain for MagicDNS (e.g., mesh.internal) |
| `magic_dns` | Boolean | Required | Enable/disable MagicDNS functionality |
| `nameservers` | List[IP] | Required if override_local_dns=true | Upstream DNS servers for queries (e.g., ["1.1.1.1", "8.8.8.8"]) |

**Relationships**:
- **1:N** with VM Nodes (one server manages multiple nodes)
- **1:N** with PreAuth Keys (server issues multiple keys)
- **1:N** with DNS Records (server maintains DNS mappings)

**State**: Stateless from entity perspective (always running), but maintains persistent database

**Storage**: SQLite database at `/var/lib/headscale/db.sqlite` (NixOS default)

---

### 2. VM Node

**Description**: A virtual machine running a Headscale-compatible client (Tailscale). Represents an endpoint in the mesh network.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `node_id` | String (UUID) | Auto-generated by Headscale | Unique identifier for the node |
| `hostname` | String | Required, unique within namespace | Hostname of the VM (e.g., client-node-1) |
| `mesh_ip` | IP Address (IPv4) | Auto-assigned from ip_prefixes | Mesh network IP address (e.g., 100.64.0.1) |
| `wireguard_public_key` | String (Base64) | Auto-generated by Tailscale client | WireGuard public key for this node |
| `namespace` | String | Required, must exist in Headscale | Logical grouping of nodes (e.g., "default") |
| `connection_status` | Enum | One of: `connected`, `disconnected`, `unknown` | Current connection state to mesh |
| `last_seen` | Timestamp | Auto-updated by Headscale | Last successful communication with server |
| `physical_ip` | IP Address (IPv4) | Read-only, provided by VM's network | Underlying network IP (e.g., 192.168.1.10 or 10.0.0.10) |
| `registered_at` | Timestamp | Auto-set on registration | When node first registered with Headscale |

**Relationships**:
- **N:1** with Headscale Server (many nodes connect to one server)
- **N:M** with WireGuard Tunnels (nodes can have tunnels to multiple peers)
- **1:1** with DNS Record (each node has one DNS entry)
- **N:1** with PreAuth Key (nodes register using a preauth key)

**State Transitions**:

```
[Unregistered] --register-with-preauth--> [Registered/Disconnected]
                                                    │
                     ┌──────────────────────────────┘
                     │
                     │ tailscale up
                     ▼
           [Registered/Connected] ◄──┐
                     │                │
                     │ network loss   │ network restored
                     ▼                │
           [Registered/Disconnected]──┘
                     │
                     │ tailscale logout or node delete
                     ▼
              [Deregistered]
```

**Validation Rules**:
- Hostname must be unique within namespace
- Mesh IP must be within ip_prefixes range
- Cannot register with expired preauth key
- Cannot have duplicate wireguard_public_key

**Storage**:
- Node metadata: Headscale SQLite database
- Client state: `/var/lib/tailscale/tailscaled.state` on VM

---

### 3. WireGuard Tunnel

**Description**: Encrypted peer-to-peer connection between two VM nodes. Automatically established by Headscale/Tailscale when nodes communicate.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `peer_a_id` | String (Node ID) | Required, foreign key to VM Node | First endpoint of the tunnel |
| `peer_b_id` | String (Node ID) | Required, foreign key to VM Node | Second endpoint of the tunnel |
| `encryption_key` | String (Base64) | Auto-negotiated by WireGuard | Symmetric encryption key for this tunnel |
| `last_handshake` | Timestamp | Auto-updated | Last successful WireGuard handshake |
| `tx_bytes` | Integer | Auto-incremented | Bytes transmitted through tunnel |
| `rx_bytes` | Integer | Auto-incremented | Bytes received through tunnel |
| `endpoint` | String (IP:Port) | Auto-discovered | Physical endpoint for NAT traversal |

**Relationships**:
- **M:1** with VM Nodes (each tunnel connects exactly two nodes)

**State**: Ephemeral - established on-demand when peers communicate, torn down after inactivity

**Validation Rules**:
- peer_a_id and peer_b_id must be different (no self-tunnels)
- Both peers must be in `connected` state
- Unique constraint on (peer_a_id, peer_b_id) pair

**Storage**: Managed by WireGuard kernel module and Tailscale daemon (not explicitly stored in Headscale database)

---

### 4. Pre-Authentication Key

**Description**: Time-limited token used to authorize new nodes to join the Headscale network without interactive authentication. Simplifies testing automation.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `key_id` | String (UUID) | Auto-generated by Headscale | Unique identifier for the key |
| `token` | String (Base64) | Auto-generated, secret | The actual authentication token used by clients |
| `namespace` | String | Required | Namespace this key grants access to |
| `reusable` | Boolean | Required | Whether key can be used for multiple registrations |
| `ephemeral` | Boolean | Default: false | If true, nodes are removed when disconnected |
| `expiration` | Timestamp | Required | When the key becomes invalid |
| `created_at` | Timestamp | Auto-set | When the key was generated |
| `used_count` | Integer | Auto-incremented | Number of times key has been used (if reusable) |

**Relationships**:
- **N:1** with Headscale Server (keys issued by server)
- **1:N** with VM Nodes (one reusable key can register multiple nodes)

**State Transitions**:

```
[Created] --time-passes--> [Expired]
             │
             │ used for registration
             ▼
        [Used] (if not reusable)
             │
             │ time passes
             ▼
        [Expired]
```

**Validation Rules**:
- Token must be unique
- Expiration must be in the future at creation time
- Non-reusable keys can only be used once
- Expired keys cannot register new nodes

**Storage**: Headscale SQLite database (preauth_keys table)

---

### 5. DNS Record

**Description**: Mapping between a VM's hostname and its mesh IP address, distributed across all nodes via MagicDNS.

**Attributes**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `fqdn` | String (FQDN) | Auto-computed | Fully qualified domain name (e.g., client-node-1.mesh.internal) |
| `hostname` | String | Foreign key to VM Node | Short hostname of the node |
| `mesh_ip` | IP Address | Foreign key to VM Node | Mesh IP address the hostname resolves to |
| `base_domain` | String | From Headscale config | Base domain for all mesh hostnames (e.g., mesh.internal) |
| `ttl` | Integer (seconds) | Default: 60 | DNS Time-To-Live for caching |
| `record_type` | Enum | Always `A` for IPv4 | DNS record type |

**Relationships**:
- **1:1** with VM Node (each node has exactly one DNS record)
- **N:1** with Headscale Server (server maintains all DNS records)

**Computed Fields**:
- `fqdn = hostname + "." + base_domain`

**State**: Automatically created when node registers, updated if hostname changes, removed when node deregistered

**Validation Rules**:
- FQDN must be unique across all nodes
- Mesh IP must match the node's assigned IP
- Hostname must be valid DNS label (alphanumeric + hyphens)

**Storage**:
- Server-side: Headscale SQLite database
- Client-side: Resolved via Tailscale local DNS resolver (no explicit storage)

**Propagation**:
- New nodes: DNS record available to all clients within ~30 seconds (MagicDNS push)
- Hostname changes: Propagated on next client sync (~60 seconds)
- Deregistered nodes: NXDOMAIN response immediately after deregistration

---

## Data Flow Diagrams

### Node Registration Flow

```
┌──────────────┐                    ┌──────────────────┐                 ┌───────────────┐
│ Admin        │                    │ Headscale Server │                 │ VM Node       │
│ (Test Script)│                    │                  │                 │ (Client)      │
└──────┬───────┘                    └────────┬─────────┘                 └───────┬───────┘
       │                                     │                                   │
       │ 1. Generate PreAuth Key             │                                   │
       ├────────────────────────────────────>│                                   │
       │                                     │                                   │
       │ 2. Return token                     │                                   │
       │<────────────────────────────────────┤                                   │
       │                                     │                                   │
       │ 3. Deploy VM with token in config   │                                   │
       ├───────────────────────────────────────────────────────────────────────>│
       │                                     │                                   │
       │                                     │ 4. tailscale up --authkey=<token> │
       │                                     │<──────────────────────────────────┤
       │                                     │                                   │
       │                                     │ 5. Validate token, create Node    │
       │                                     │    - Assign mesh IP               │
       │                                     │    - Store WG public key          │
       │                                     │    - Create DNS record            │
       │                                     │                                   │
       │                                     │ 6. Return mesh config             │
       │                                     ├──────────────────────────────────>│
       │                                     │                                   │
       │                                     │                                   │
       │ 7. Query node status                │                                   │
       ├────────────────────────────────────>│                                   │
       │                                     │                                   │
       │ 8. Return node details              │                                   │
       │<────────────────────────────────────┤                                   │
```

### Mesh Communication Flow

```
┌───────────────┐                 ┌───────────────┐                 ┌───────────────┐
│ Node A        │                 │ Headscale     │                 │ Node B        │
│ (100.64.0.1)  │                 │ Server        │                 │ (100.64.0.2)  │
└───────┬───────┘                 └───────┬───────┘                 └───────┬───────┘
        │                                 │                                 │
        │ 1. DNS query: node-b.mesh.internal                                │
        ├────────────────────────────────>│                                 │
        │                                 │                                 │
        │ 2. Return 100.64.0.2            │                                 │
        │<────────────────────────────────┤                                 │
        │                                 │                                 │
        │ 3. Ping 100.64.0.2              │                                 │
        │    (triggers WireGuard tunnel)  │                                 │
        ├─────────────────────────────────┼────────────────────────────────>│
        │                                 │                                 │
        │                                 │ (WireGuard establishes          │
        │                                 │  encrypted tunnel directly      │
        │                                 │  between Node A and Node B)     │
        │                                 │                                 │
        │ 4. Encrypted ping reply via WG tunnel                             │
        │<──────────────────────────────────────────────────────────────────┤
        │                                 │                                 │
```

---

## Entity Lifecycle Summary

| Entity | Creation | Persistence | Destruction |
|--------|----------|-------------|-------------|
| Headscale Server | NixOS service start | StateDirectory (/var/lib/headscale) | VM deletion |
| VM Node | `tailscale up --authkey` | Headscale DB + client state file | `tailscale logout` or `headscale nodes delete` |
| WireGuard Tunnel | First packet between peers | Ephemeral (kernel WireGuard module) | Peer disconnection or timeout |
| PreAuth Key | `headscale preauthkeys create` | Headscale DB | Expiration or manual deletion |
| DNS Record | Node registration | Headscale DB | Node deregistration |

---

## Validation Matrix

| Scenario | Validation | Expected Behavior |
|----------|------------|-------------------|
| Duplicate hostname | Hostname must be unique per namespace | Registration fails with error |
| Expired preauth key | Check expiration before accepting | Registration fails with "key expired" |
| Node offline | Connection status transitions to `disconnected` | DNS record remains, tunnel teardown after timeout |
| Network partition | Some nodes can reach server, some cannot | Partitioned nodes show `disconnected`, others `connected` |
| Mesh IP conflict | IP allocation from available pool | Should never occur (Headscale guarantees uniqueness) |
| Invalid DNS label in hostname | Alphanumeric + hyphen validation | Registration fails or hostname sanitized |

---

## Index and Query Patterns

For efficient test validation, these query patterns are commonly used:

```bash
# List all registered nodes in namespace
headscale nodes list --namespace default

# Get specific node details
headscale nodes show <node-id>

# Check DNS resolution
tailscale ping node-b.mesh.internal

# View tunnel status
tailscale status

# List active preauth keys
headscale preauthkeys list --namespace default
```

---

This data model provides the foundation for implementing the NixOS modules and test orchestration scripts in Phase 2.
