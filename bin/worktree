#!/usr/bin/env python3

import os
import re
import shutil
import subprocess
import sys


def run_command(command, check=True, capture_output=False, cwd=None):
    """Helper to run shell commands."""
    try:
        process = subprocess.run(command, check=False, capture_output=capture_output, text=True, shell=True, cwd=cwd)
        if process.returncode != 0 and check:
            print(f"Error executing command: {command}", file=sys.stderr)
            if process.stdout:
                print(f"Stdout: {process.stdout.strip()}", file=sys.stderr)
            if process.stderr:
                print(f"Stderr: {process.stderr.strip()}", file=sys.stderr)
            sys.exit(process.returncode)
        
        return process.stdout.strip() if capture_output else True
    except FileNotFoundError:
        print(f"Command not found: {command.split()[0]}", file=sys.stderr)
        sys.exit(1)

def sluggify(value):
    """
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.
    """
    value = str(value)
    # Replace slashes with hyphens
    value = value.replace('/', '-')
    # Keep alphanumeric and hyphens, remove others
    value = re.sub(r'[^\w\-]', '', value)
    # Convert to lowercase
    value = value.lower()
    return value

def get_worktree_path(branch_name):
    """Returns the expected path for a worktree."""
    return os.path.join(".worktrees", sluggify(branch_name))

def cmd_list():
    """Lists all active worktrees."""
    print("Listing git worktrees:")
    run_command("git worktree list")

def cmd_add(branch_name, base_ref=None):
    """Adds a new worktree."""
    worktree_path = get_worktree_path(branch_name)

    # Check if directory already exists BEFORE checking git
    if os.path.exists(worktree_path):
        print(f"Worktree directory '{worktree_path}' already exists. Skipping git worktree creation.")
        # Run direnv allow if direnv is installed
        if shutil.which("direnv"):
            print(f"Running 'direnv allow' in {worktree_path}...")
            run_command(f"direnv allow {worktree_path}", check=False)
        return

    print(f"Creating worktree for branch '{branch_name}' at '{worktree_path}'...")

    if not os.path.exists(".worktrees"):
        os.makedirs(".worktrees")
        print(f"Created directory: .worktrees/")

    git_command_prefix = "git" # Assuming git is in PATH

    # Check if the branch already exists
    branch_exists_result = subprocess.run(
        f"{git_command_prefix} show-ref --verify --quiet refs/heads/{branch_name}",
        shell=True,
        capture_output=True
    )
    branch_exists = branch_exists_result.returncode == 0

    if base_ref:
        command = f"{git_command_prefix} worktree add -b {branch_name} {worktree_path} {base_ref}"
    elif branch_exists:
        command = f"{git_command_prefix} worktree add {worktree_path} {branch_name}"
    else: # branch does not exist, create it from current HEAD
        command = f"{git_command_prefix} worktree add -b {branch_name} {worktree_path}"
    
    run_command(command)
    
    # Run direnv allow if direnv is installed
    if shutil.which("direnv"):
        print(f"Running 'direnv allow' in {worktree_path}...")
        run_command(f"direnv allow {worktree_path}", check=False)

def cmd_remove(branch_name):
    """Removes a worktree."""
    worktree_path = get_worktree_path(branch_name)
    print(f"Removing worktree for branch '{branch_name}' at '{worktree_path}'...")
    
    if not os.path.exists(worktree_path):
        print(f"Error: Worktree path '{worktree_path}' does not exist.", file=sys.stderr)
        sys.exit(1)

    # Git worktree remove requires being outside the worktree itself
    current_dir = os.getcwd()
    # Get absolute path of worktree for comparison
    worktree_full_path = os.path.abspath(worktree_path)

    # Check if current_dir is the worktree_full_path or a subdirectory of it
    if current_dir == worktree_full_path or current_dir.startswith(worktree_full_path + os.sep):
        print(f"Error: Cannot remove worktree from inside its directory ('{worktree_path}'). Please run 'bin/worktree remove' from the project root.", file=sys.stderr)
        sys.exit(1)

    run_command(f"git worktree remove {worktree_path}")
    print(f"Worktree '{branch_name}' removed successfully.")
    
    # Clean up the directory if git leaves anything behind
    if os.path.exists(worktree_path):
        try:
            os.rmdir(worktree_path)
            print(f"Cleaned up empty directory '{worktree_path}'.")
        except OSError as e:
            print(f"Warning: Directory '{worktree_path}' was not empty after removal or could not be removed: {e}. Manual cleanup may be required.", file=sys.stderr)


def main():
    if len(sys.argv) < 2:
        print("Usage: bin/worktree <command> [args]", file=sys.stderr)
        print("Commands: list, add <branch-name> [base-ref], remove <branch-name>", file=sys.stderr)
        sys.exit(1)

    command = sys.argv[1]

    if command == "list":
        cmd_list()
    elif command == "add":
        if len(sys.argv) < 3:
            print("Usage: bin/worktree add <branch-name> [base-ref]", file=sys.stderr)
            sys.exit(1)
        branch_name = sys.argv[2]
        base_ref = sys.argv[3] if len(sys.argv) > 3 else None
        cmd_add(branch_name, base_ref)
    elif command == "remove":
        if len(sys.argv) < 3:
            print("Usage: bin/worktree remove <branch-name>", file=sys.stderr)
            sys.exit(1)
        branch_name = sys.argv[2]
        cmd_remove(branch_name)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print(f"Did you mean: bin/worktree add {command}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()