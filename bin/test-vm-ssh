#!/usr/bin/env python3
"""
test-vm-ssh - SSH into whitelisted Keystone test VMs

This script provides a clean way to SSH into test VMs without
polluting your user SSH configuration or cluttering agent context with warnings.

Usage:
    ./bin/test-vm-ssh                           # Connect to default VM (keystone-test-vm)
    ./bin/test-vm-ssh build-vm-terminal         # Connect to build-vm-terminal
    ./bin/test-vm-ssh build-vm-terminal "ls"    # Run command on build-vm-terminal
    ./bin/test-vm-ssh keystone-test-vm "ls -la" # Run command on keystone-test-vm

Features:
    - Isolated known_hosts file (won't pollute ~/.ssh/known_hosts)
    - Suppresses SSH warnings for clean agent context
    - Checks VM is running before attempting connection
    - Supports multiple whitelisted VMs
"""

import os
import sys
import subprocess
import time
from pathlib import Path

# Whitelisted VM configurations
VM_CONFIGS = {
    "keystone-test-vm": {
        "host": "192.168.100.99",
        "port": 22,
        "user": "root",
        "check_virsh": True,
        "description": "Libvirt test VM with full stack"
    },
    "build-vm-terminal": {
        "host": "localhost",
        "port": 2222,
        "user": "testuser",
        "check_virsh": False,
        "description": "Terminal dev environment test VM"
    },
    "build-vm-desktop": {
        "host": "localhost",
        "port": 2223,
        "user": "testuser",
        "check_virsh": False,
        "description": "Desktop Hyprland test VM"
    }
}

# Default VM if none specified
DEFAULT_VM = "keystone-test-vm"
KNOWN_HOSTS_FILE = "/tmp/keystone-test-vm-known-hosts"

# ANSI colors
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
NC = '\033[0m'  # No Color


def log(color, message):
    """Print colored message to stderr."""
    print(f"{color}{message}{NC}", file=sys.stderr)


def check_vm_running(vm_name, vm_config, verbose=False):
    """Check if the VM exists and is running."""
    # Skip virsh check if not required
    if not vm_config["check_virsh"]:
        return

    # Check if virsh is available
    if not subprocess.run(["which", "virsh"], capture_output=True).returncode == 0:
        if verbose:
            log(RED, "Error: virsh not found. Is libvirt installed?")
        sys.exit(1)

    # Check VM state
    result = subprocess.run(
        ["virsh", "domstate", vm_name],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        if verbose:
            log(RED, f"Error: VM '{vm_name}' does not exist.")
            log(YELLOW, f"Create it with: ./bin/virtual-machine --name {vm_name} --start")
        sys.exit(1)

    vm_state = result.stdout.strip()
    if vm_state != "running":
        if verbose:
            log(RED, f"Error: VM '{vm_name}' is not running (state: {vm_state}).")
            log(YELLOW, f"Start it with: virsh start {vm_name}")
        sys.exit(1)


def wait_for_ssh(vm_config, max_attempts=5, verbose=False):
    """Wait for SSH to be available on the VM."""
    host = vm_config["host"]
    port = vm_config["port"]
    user = vm_config["user"]

    ssh_opts = [
        "-p", str(port),
        "-o", "ConnectTimeout=2",
        "-o", "StrictHostKeyChecking=no",
        "-o", f"UserKnownHostsFile={KNOWN_HOSTS_FILE}",
        "-o", "LogLevel=ERROR",
        "-q"
    ]

    for attempt in range(1, max_attempts + 1):
        result = subprocess.run(
            ["ssh"] + ssh_opts + [f"{user}@{host}", "exit 0"],
            capture_output=True,
            stderr=subprocess.DEVNULL
        )

        if result.returncode == 0:
            return True

        if attempt == max_attempts:
            if verbose:
                log(RED, f"Error: Could not connect to SSH after {max_attempts} attempts.")
                log(YELLOW, f"Make sure sshd is running and port {port} is accessible.")
            return False

        time.sleep(2)

    return False


def filter_ssh_output(line):
    """Filter out SSH warnings from output."""
    warnings = [
        "Warning: Permanently added",
        "Offending ECDSA key",
        "Warning: the ECDSA host key"
    ]
    return not any(warning in line for warning in warnings)


def run_ssh(vm_name, vm_config, command=None, verbose=False):
    """Run SSH connection, either interactive or with a command."""
    host = vm_config["host"]
    port = vm_config["port"]
    user = vm_config["user"]

    ssh_opts = [
        "-p", str(port),
        "-o", "StrictHostKeyChecking=no",
        "-o", f"UserKnownHostsFile={KNOWN_HOSTS_FILE}",
        "-o", "LogLevel=QUIET",
        "-o", "ServerAliveInterval=60",
        "-o", "ServerAliveCountMax=3"
    ]

    ssh_cmd = ["ssh"] + ssh_opts

    if command:
        # Run command mode - suppress all SSH warnings
        ssh_cmd.extend([f"{user}@{host}", command])

        try:
            process = subprocess.Popen(
                ssh_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                text=True,
                bufsize=1
            )

            # Stream output line by line, filtering any remaining warnings
            for line in process.stdout:
                if filter_ssh_output(line):
                    print(line, end='')

            process.wait()
            sys.exit(process.returncode)

        except KeyboardInterrupt:
            sys.exit(130)
    else:
        # Interactive mode - pass through to terminal but suppress warnings
        ssh_cmd.extend(["-t", f"{user}@{host}"])

        try:
            # For interactive mode, redirect stderr to devnull to suppress all warnings
            result = subprocess.run(
                ssh_cmd,
                stderr=subprocess.DEVNULL
            )
            sys.exit(result.returncode)

        except KeyboardInterrupt:
            sys.exit(130)


def list_vms():
    """List available whitelisted VMs."""
    log(GREEN, "Available VMs:")
    for vm_name, config in VM_CONFIGS.items():
        default = " (default)" if vm_name == DEFAULT_VM else ""
        log(YELLOW, f"  {vm_name}{default}")
        print(f"    {config['description']}", file=sys.stderr)
        print(f"    {config['user']}@{config['host']}:{config['port']}", file=sys.stderr)


def main():
    """Main entry point."""
    # Parse arguments
    verbose = "--verbose" in sys.argv or "-v" in sys.argv
    args = [arg for arg in sys.argv[1:] if arg not in ["--verbose", "-v"]]

    vm_name = DEFAULT_VM
    command_args = []

    if len(args) > 0:
        # Check if first arg is a VM name or --list
        if args[0] == "--list":
            list_vms()
            sys.exit(0)
        elif args[0] in VM_CONFIGS:
            vm_name = args[0]
            command_args = args[1:]
        else:
            # First arg is part of command, use default VM
            command_args = args

    # Get VM config
    if vm_name not in VM_CONFIGS:
        if verbose:
            log(RED, f"Error: Unknown VM '{vm_name}'")
            log(YELLOW, "Available VMs:")
            for name in VM_CONFIGS.keys():
                log(YELLOW, f"  {name}")
        sys.exit(1)

    vm_config = VM_CONFIGS[vm_name]

    # Check VM running state (silent unless verbose)
    check_vm_running(vm_name, vm_config, verbose)

    # Wait for SSH (silent unless verbose)
    if not wait_for_ssh(vm_config, verbose=verbose):
        sys.exit(1)

    # Build command if arguments provided
    command = " ".join(command_args) if command_args else None
    run_ssh(vm_name, vm_config, command, verbose)


if __name__ == "__main__":
    main()
