#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "libvirt-python>=9.0.0",
# ]
# ///
"""
Create a libvirt VM with UEFI Secure Boot enabled for NixOS (NixOS-compatible version)
Outputs to both serial console and graphical display

NixOS requirements:
  Add to your configuration.nix:
    virtualisation.libvirtd.enable = true;
    users.users.<youruser>.extraGroups = [ "libvirtd" ];
"""

import libvirt
import sys
import os
import xml.etree.ElementTree as ET
import subprocess
import glob

def validate_nvram_setup_mode(nvram_path):
    """
    Check if NVRAM file appears to be in setup mode (no pre-enrolled keys)

    Args:
        nvram_path: Path to NVRAM file (OVMF_VARS.fd copy)

    Returns:
        tuple: (is_valid, message)
            is_valid (bool): True if NVRAM appears to be in setup mode
            message (str): Warning message if validation fails, None otherwise
    """
    if not os.path.exists(nvram_path):
        return True, None  # Will be created from template

    # Empty template should be exactly 540,672 bytes
    expected_size = 540672
    actual_size = os.path.getsize(nvram_path)

    # Allow 10KB variance for metadata
    if actual_size > expected_size + 10000:
        warning = (
            f"⚠️  WARNING: NVRAM file is larger than expected\n"
            f"    Expected: ~{expected_size} bytes (empty template)\n"
            f"    Actual:   {actual_size} bytes\n"
            f"    This may indicate pre-enrolled keys.\n"
            f"    VM may NOT boot in setup mode.\n"
            f"    To reset: rm {nvram_path}"
        )
        return False, warning

    return True, None


def find_ovmf_firmware():
    """
    Find OVMF firmware files on NixOS
    """
    # First priority: Check QEMU's EDK2 Secure Boot firmware (NixOS)
    try:
        qemu_path = subprocess.run(
            ["which", "qemu-system-x86_64"],
            capture_output=True, text=True
        ).stdout.strip()

        if qemu_path:
            # Resolve symlinks to get real Nix store path
            real_path = subprocess.run(
                ["readlink", "-f", qemu_path],
                capture_output=True, text=True
            ).stdout.strip()

            # Get the QEMU package directory
            qemu_store_path = "/".join(real_path.split("/")[:-2])
            qemu_share = os.path.join(qemu_store_path, "share/qemu")

            # Check for EDK2 Secure Boot firmware
            edk2_secure_code = os.path.join(qemu_share, "edk2-x86_64-secure-code.fd")
            edk2_vars = os.path.join(qemu_share, "edk2-i386-vars.fd")

            if os.path.exists(edk2_secure_code) and os.path.exists(edk2_vars):
                return edk2_secure_code, edk2_vars
    except:
        pass

    # Second priority: Check for OVMF in Nix store via common paths
    nix_paths = [
        # Try to find via nix-store
        subprocess.run(
            ["nix-build", "--no-out-link", "<nixpkgs>", "-A", "OVMF.fd"],
            capture_output=True, text=True
        ).stdout.strip(),
        # Look in /nix/store directly
        *glob.glob("/nix/store/*-OVMF-*-fd/FV/"),
    ]

    for base_path in nix_paths:
        if not base_path:
            continue

        # Look for Secure Boot variants first
        code_candidates = [
            os.path.join(base_path, "FV/OVMF_CODE.secboot.fd"),
            os.path.join(base_path, "FV/OVMF_CODE.fd"),
        ]
        vars_candidates = [
            os.path.join(base_path, "FV/OVMF_VARS.secboot.fd"),
            os.path.join(base_path, "FV/OVMF_VARS.fd"),
        ]

        for code in code_candidates:
            for vars in vars_candidates:
                if os.path.exists(code) and os.path.exists(vars):
                    return code, vars

    # Fallback to traditional paths (non-NixOS)
    traditional_paths = [
        ("/usr/share/OVMF/OVMF_CODE_4M.secboot.fd", "/usr/share/OVMF/OVMF_VARS_4M.ms.fd"),
        ("/usr/share/edk2/ovmf/OVMF_CODE.secboot.fd", "/usr/share/edk2/ovmf/OVMF_VARS.secboot.fd"),
    ]

    for code, vars in traditional_paths:
        if os.path.exists(code) and os.path.exists(vars):
            return code, vars

    return None, None

def create_uefi_secureboot_vm(
    conn,
    vm_name="keystone-test-vm",
    memory_mb=4096,
    vcpus=2,
    disk_path=None,
    disk_size_gb=20,
    iso_path=None,
    ssh_port=22222,
):
    """
    Create a VM with UEFI Secure Boot enabled in Setup Mode

    Args:
        conn: libvirt connection object
        vm_name: Name of the VM
        memory_mb: RAM in MB
        vcpus: Number of virtual CPUs
        disk_path: Path to disk image (created if doesn't exist)
        disk_size_gb: Size of disk if creating new
        iso_path: Path to installation ISO (optional)
        ssh_port: Host port for SSH forwarding (default 22222)

    Returns:
        libvirt.virDomain: Domain object for created VM

    Raises:
        SystemExit(1): If OVMF firmware not found or VM creation fails

    Postconditions:
        - VM defined in libvirt with Secure Boot enabled
        - NVRAM file created from empty OVMF_VARS template
        - VM in Setup Mode (no keys enrolled, SetupMode=1)
        - Running `bootctl status` in VM shows "Secure Boot: disabled (setup)"
    """

    # Set default disk path to vms/ directory
    if disk_path is None:
        vm_dir = f"vms/{vm_name}"
        disk_path = f"{vm_dir}/disk.qcow2"

    # Convert to absolute path
    disk_path = os.path.abspath(disk_path)

    # Ensure VM directory exists
    vm_dir = os.path.dirname(disk_path)
    os.makedirs(vm_dir, exist_ok=True)

    # Create disk image if it doesn't exist
    if not os.path.exists(disk_path):
        print(f"Creating disk image: {disk_path}")
        ret = os.system(f"qemu-img create -f qcow2 {disk_path} {disk_size_gb}G")
        if ret != 0:
            print(f"ERROR: Failed to create disk image")
            sys.exit(1)

    # NVRAM path in vms/ directory
    vm_dir = os.path.dirname(disk_path)
    nvram_path = os.path.join(vm_dir, "OVMF_VARS.fd")

    # Find OVMF firmware files
    print("Searching for OVMF firmware...")
    ovmf_code, ovmf_vars = find_ovmf_firmware()

    if not ovmf_code or not ovmf_vars:
        print("ERROR: OVMF firmware not found!")
        print("On NixOS, ensure you have OVMF available:")
        print("  Add to configuration.nix: virtualisation.libvirtd.enable = true;")
        print("  Or install manually: nix-env -iA nixos.OVMF")
        sys.exit(1)

    # Verify Secure Boot firmware is available (non-optional)
    if "secure" not in ovmf_code.lower():
        print("ERROR: Secure Boot firmware not found!")
        print("This script requires Secure Boot enabled OVMF firmware.")
        print(f"Found: {ovmf_code}")
        print(f"Expected: edk2-x86_64-secure-code.fd or OVMF_CODE.secboot.fd")
        print("\nOn NixOS, ensure QEMU with EDK2 Secure Boot firmware is available:")
        print("  Add to configuration.nix:")
        print("    virtualisation.libvirtd.enable = true;")
        print("  Then rebuild:")
        print("    sudo nixos-rebuild switch")
        sys.exit(1)

    print(f"✓ Found OVMF CODE: {ovmf_code}")
    print(f"✓ Found OVMF VARS: {ovmf_vars}")

    # Copy OVMF vars template to VM-specific NVRAM
    if not os.path.exists(nvram_path):
        os.makedirs(os.path.dirname(nvram_path), exist_ok=True)

        # Validate VARS template before copying
        is_valid, warning = validate_nvram_setup_mode(ovmf_vars)
        if not is_valid:
            print(warning)

        os.system(f"cp {ovmf_vars} {nvram_path}")
        print(f"✓ Created NVRAM: {nvram_path}")
    else:
        # Validate existing NVRAM file
        is_valid, warning = validate_nvram_setup_mode(nvram_path)
        if not is_valid:
            print(warning)

    print(f"✓ Secure Boot enabled")

    # Build XML configuration
    xml_config = f"""
<domain type='kvm'>
  <name>{vm_name}</name>
  <memory unit='MiB'>{memory_mb}</memory>
  <vcpu placement='static'>{vcpus}</vcpu>

  <os>
    <type arch='x86_64' machine='q35'>hvm</type>
    <loader readonly='yes' secure='yes' type='pflash'>{ovmf_code}</loader>
    <nvram template='{ovmf_vars}'>{nvram_path}</nvram>
    <boot dev='hd'/>
    {"<boot dev='cdrom'/>" if iso_path else ""}
  </os>

  <features>
    <acpi/>
    <apic/>
    <smm state='on'>
      <tseg unit='MiB'>48</tseg>
    </smm>
  </features>

  <cpu mode='host-passthrough' check='none'/>

  <clock offset='utc'>
    <timer name='rtc' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='delay'/>
    <timer name='hpet' present='no'/>
  </clock>

  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>

  <devices>
    <emulator>/run/current-system/sw/bin/qemu-system-x86_64</emulator>
    
    <!-- Main disk -->
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='{disk_path}'/>
      <target dev='vda' bus='virtio'/>
    </disk>
    
    <!-- Installation ISO (if provided) -->
    {"" if not iso_path else f"""
    <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <source file='{iso_path}'/>
      <target dev='sda' bus='sata'/>
      <readonly/>
    </disk>
    """}
    
    <!-- Network with static IP via keystone-net -->
    <interface type='network'>
      <source network='keystone-net'/>
      <mac address='52:54:00:72:a2:99'/>
      <model type='virtio'/>
    </interface>
    
    <!-- Serial console (PTY) -->
    <serial type='pty'>
      <target type='isa-serial' port='0'>
        <model name='isa-serial'/>
      </target>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    
    <!-- Graphics for remote-viewer -->
    <graphics type='spice' autoport='yes'>
      <listen type='address' address='127.0.0.1'/>
    </graphics>
    <video>
      <model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='1'/>
    </video>
    
    <!-- Input devices -->
    <input type='tablet' bus='usb'/>
    <input type='keyboard' bus='usb'/>
    
    <!-- TPM 2.0 (useful for Windows 11 and Secure Boot) -->
    <tpm model='tpm-crb'>
      <backend type='emulator' version='2.0'/>
    </tpm>
  </devices>
</domain>
"""
    
    try:
        # Define the VM
        dom = conn.defineXML(xml_config)
        print(f"✓ VM '{vm_name}' defined successfully")
        print(f"✓ Secure Boot enabled")

        return dom

    except libvirt.libvirtError as e:
        print(f"ERROR: Failed to create VM: {e}")
        sys.exit(1)


def post_install_reboot(conn, vm_name):
    """
    Post-installation cleanup: detach ISO, snapshot disk, and reboot
    VM must be shut down before running this
    """
    try:
        dom = conn.lookupByName(vm_name)
        
        # Check if VM is shut down
        if dom.isActive():
            print(f"ERROR: VM '{vm_name}' is still running!")
            print("Please shut down the VM first:")
            print(f"  virsh shutdown {vm_name}")
            print("Wait for it to power off, then run this command again.")
            sys.exit(1)
        
        print(f"✓ VM '{vm_name}' is shut down")
        
        # Get disk path from XML
        xml = dom.XMLDesc(0)
        root = ET.fromstring(xml)
        
        disk_path = None
        for disk in root.findall('.//disk[@device="disk"]'):
            source = disk.find('source')
            if source is not None:
                disk_path = source.get('file')
                break
        
        # Create snapshot of disk
        if disk_path:
            snapshot_name = f"{os.path.basename(disk_path)}.post-install-snapshot"
            snapshot_path = os.path.join(os.path.dirname(disk_path), snapshot_name)
            
            print(f"Creating disk snapshot: {snapshot_name}")
            ret = os.system(f"qemu-img snapshot -c post-install {disk_path}")
            if ret != 0:
                print(f"WARNING: Snapshot creation failed")
            else:
                print(f"✓ Disk snapshot 'post-install' created")
        
        # Remove cdrom device from XML
        devices = root.find('devices')
        removed = False
        for disk in devices.findall('disk'):
            if disk.get('device') == 'cdrom':
                devices.remove(disk)
                removed = True
        
        if removed:
            # Update the domain configuration
            new_xml = ET.tostring(root, encoding='unicode')
            conn.defineXML(new_xml)
            print(f"✓ ISO detached from '{vm_name}'")
        else:
            print("ℹ No ISO was attached")
        
        # Start the VM
        dom.create()
        print(f"✓ VM '{vm_name}' started")
        print("\nPost-installation setup complete!")
        
    except libvirt.libvirtError as e:
        print(f"ERROR: {e}")
        sys.exit(1)


def reset_setup_mode(conn, vm_name):
    """
    Reset VM NVRAM to Setup Mode (delete and recreate from template)
    VM must be shut down before running this
    """
    try:
        dom = conn.lookupByName(vm_name)

        # Check if VM is shut down
        if dom.isActive():
            print(f"ERROR: VM '{vm_name}' is still running!")
            print(f"Shut down the VM first: virsh shutdown {vm_name}")
            sys.exit(1)

        # Get NVRAM path from XML
        xml = dom.XMLDesc(0)
        root = ET.fromstring(xml)
        nvram_elem = root.find('.//os/nvram')

        if nvram_elem is None or not nvram_elem.text:
            print(f"ERROR: No NVRAM file found for VM '{vm_name}'")
            sys.exit(1)

        nvram_path = nvram_elem.text
        nvram_template = nvram_elem.get('template')

        if not nvram_template:
            print(f"WARNING: No NVRAM template attribute found in VM XML")
            print(f"Will delete NVRAM, but you may need to manually recreate the VM")

        # Delete existing NVRAM
        if os.path.exists(nvram_path):
            os.remove(nvram_path)
            print(f"✓ Deleted NVRAM: {nvram_path}")
        else:
            print(f"ℹ NVRAM file does not exist: {nvram_path}")

        # Recreate from template if available
        if nvram_template and os.path.exists(nvram_template):
            os.makedirs(os.path.dirname(nvram_path), exist_ok=True)
            os.system(f"cp {nvram_template} {nvram_path}")
            print(f"✓ Recreated NVRAM from template: {nvram_template}")
            print(f"✓ VM '{vm_name}' reset to Setup Mode")
            print(f"\nNext steps:")
            print(f"  virsh start {vm_name}")
            print(f"  virsh console {vm_name}")
            print(f"  # Inside VM: bootctl status")
        else:
            print(f"✓ NVRAM deleted")
            print(f"ℹ To recreate the VM with fresh NVRAM:")
            print(f"  ./bin/virtual-machine --reset {vm_name}")
            print(f"  ./bin/virtual-machine --name {vm_name} --start")

    except libvirt.libvirtError as e:
        if "Domain not found" in str(e):
            print(f"ERROR: VM '{vm_name}' does not exist")
        else:
            print(f"ERROR: {e}")
        sys.exit(1)


def reset_vm(conn, vm_name):
    """
    Completely delete VM and all associated files (no confirmation)
    """
    try:
        dom = conn.lookupByName(vm_name)
        
        # Get all file paths before deletion
        xml = dom.XMLDesc(0)
        root = ET.fromstring(xml)
        
        disk_paths = []
        for disk in root.findall('.//disk[@device="disk"]'):
            source = disk.find('source')
            if source is not None:
                disk_paths.append(source.get('file'))
        
        nvram_path = None
        nvram = root.find('.//os/nvram')
        if nvram is not None:
            nvram_path = nvram.text
        
        # Force destroy if running
        if dom.isActive():
            print(f"⚠ Destroying running VM '{vm_name}'...")
            dom.destroy()
            print(f"✓ VM destroyed")
        
        print(f"Deleting VM '{vm_name}' and all associated files...")
        
        # Undefine VM with NVRAM
        try:
            dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
            print(f"✓ VM '{vm_name}' undefined")
        except:
            dom.undefine()
            print(f"✓ VM '{vm_name}' undefined")
        
        # Delete disk files
        for disk_path in disk_paths:
            if os.path.exists(disk_path):
                os.remove(disk_path)
                print(f"✓ Deleted: {disk_path}")
        
        # Delete NVRAM if not already removed
        if nvram_path and os.path.exists(nvram_path):
            os.remove(nvram_path)
            print(f"✓ Deleted: {nvram_path}")
        
        print(f"\n✓ VM '{vm_name}' completely removed!")
        
    except libvirt.libvirtError as e:
        if "Domain not found" in str(e):
            print(f"ERROR: VM '{vm_name}' does not exist")
        else:
            print(f"ERROR: {e}")
        sys.exit(1)


def get_serial_pty(conn, vm_name):
    """
    Get the PTY device path for the serial console
    """
    try:
        dom = conn.lookupByName(vm_name)
        if not dom.isActive():
            return None
        
        xml = dom.XMLDesc(0)
        root = ET.fromstring(xml)
        
        for serial in root.findall('.//serial[@type="pty"]'):
            source = serial.find('source')
            if source is not None:
                return source.get('path')
        
        return None
    except:
        return None


def print_connection_commands(vm_name, ssh_port):
    """
    Print helpful connection commands
    """
    print("\n" + "="*70)
    print(f"VM '{vm_name}' READY")
    print("="*70)
    
    print("\n📋 MANAGEMENT COMMANDS:")
    print(f"  Start VM:       virsh start {vm_name}")
    print(f"  Stop VM:        virsh shutdown {vm_name}")
    print(f"  Force stop:     virsh destroy {vm_name}")
    print(f"  Delete VM:      python3 {sys.argv[0]} --reset {vm_name}")
    print(f"  VM info:        virsh dominfo {vm_name}")
    
    print("\n🔌 CONNECTION OPTIONS:")
    
    print("\n  1️⃣  Graphical Display (remote-viewer):")
    print(f"      remote-viewer spice://localhost:$(virsh domdisplay {vm_name} | grep -oP '(?<=:)\\d+')")
    print("      OR simply:")
    print(f"      remote-viewer $(virsh domdisplay {vm_name})")
    
    print("\n  2️⃣  Serial Console (virsh):")
    print(f"      virsh console {vm_name}")
    print("      (Press Ctrl+] to exit)")
    
    print("\n  3️⃣  Serial Console (socat):")
    print(f"      # First start the VM, then find PTY device:")
    print(f"      virsh dumpxml {vm_name} | grep \"serial type='pty'\" -A 1")
    print("      # Then connect with socat (replace /dev/pts/X with actual PTY):")
    print("      socat -,raw,echo=0,escape=0x1d /dev/pts/X")
    print("      (Press Ctrl+] to exit)")
    
    print("\n  4️⃣  SSH (after installing SSH server in guest):")
    print(f"      ssh root@192.168.100.99")
    print(f"      or: ssh root@keystone-test-vm")
    print(f"      (VM has static IP 192.168.100.99 on keystone-net)")
    
    print("\n💿 POST-INSTALLATION:")
    print(f"  After NixOS installation completes:")
    print(f"  1. Shut down the VM:  virsh shutdown {vm_name}")
    print(f"  2. Run post-install:  python3 {sys.argv[0]} --post-install-reboot {vm_name}")
    print(f"     (This will: snapshot disk, remove ISO, and reboot)")
    
    print("\n🔒 VERIFY SECURE BOOT SETUP MODE:")
    print("  VMs are created with Secure Boot enabled in Setup Mode (no keys enrolled).")
    print("  This allows testing custom key enrollment and Keystone installer integration.")
    print()
    print("  Inside the VM after booting from the installer ISO:")
    print("    bootctl status")
    print()
    print("  Expected output:")
    print("    System:")
    print("         Firmware: UEFI 2.70 (EDK II 1.00)")
    print("      Secure Boot: disabled (setup)")
    print("       Setup Mode: setup")
    print()
    print("  What this means:")
    print("    • 'Secure Boot: disabled (setup)' - Firmware has Secure Boot capability")
    print("    • 'Setup Mode: setup' - No Platform Key (PK) enrolled, ready for key enrollment")
    print("    • OS installer can enroll custom Secure Boot keys")
    print()
    print("  Alternative verification:")
    print("    # Check SetupMode variable (should be 1)")
    print("    od --address-radix=n --format=u1 /sys/firmware/efi/efivars/SetupMode-*")
    print("    # Last byte should be: 1")
    print()
    print("  After key enrollment (post-installation):")
    print("    bootctl status")
    print("    # Should show: Secure Boot: enabled (user)")
    
    print("\n📝 NixOS GUEST SETUP:")
    print("  • Serial console is automatically configured during NixOS install")
    print("  • To enable serial console in your configuration.nix:")
    print("    boot.kernelParams = [ \"console=tty0\" \"console=ttyS0,115200\" ];")
    print("  • For SSH access, ensure in configuration.nix:")
    print("    services.openssh.enable = true;")
    print("="*70 + "\n")


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Create UEFI Secure Boot VM for NixOS (NixOS-compatible)')
    parser.add_argument('--name', default='keystone-test-vm', help='VM name')
    parser.add_argument('--memory', type=int, default=4096, help='Memory in MB')
    parser.add_argument('--vcpus', type=int, default=2, help='Number of vCPUs')
    parser.add_argument('--disk-size', type=int, default=30, help='Disk size in GB')
    parser.add_argument('--iso', help='Path to NixOS installation ISO (default: vms/keystone-installer.iso)')
    parser.add_argument('--ssh-port', type=int, default=22220, help='SSH port on host')
    parser.add_argument('--post-install-reboot', metavar='VM_NAME', help='Post-install: snapshot disk, remove ISO, reboot (VM must be shut down)')
    parser.add_argument('--reset', metavar='VM_NAME', help='Delete VM and all associated files (forces destroy if running)')
    parser.add_argument('--reset-setup-mode', metavar='VM_NAME', help='Reset VM NVRAM to Setup Mode (VM must be shut down)')
    parser.add_argument('--start', action='store_true', help='Start VM after creation')

    args = parser.parse_args()

    # Connect to libvirt
    try:
        conn = libvirt.open('qemu:///system')
        if conn is None:
            print('Failed to open connection to qemu:///system')
            sys.exit(1)
        print("✓ Connected to libvirt")
    except libvirt.libvirtError as e:
        print(f"ERROR: {e}")
        print("\nOn NixOS, ensure libvirtd is enabled:")
        print("  Add to configuration.nix:")
        print("    virtualisation.libvirtd.enable = true;")
        print("    users.users.<youruser>.extraGroups = [ \"libvirtd\" ];")
        sys.exit(1)
    
    # Handle post-installation reboot
    if args.post_install_reboot:
        post_install_reboot(conn, args.post_install_reboot)
        conn.close()
        return

    # Handle reset to setup mode
    if args.reset_setup_mode:
        reset_setup_mode(conn, args.reset_setup_mode)
        conn.close()
        return

    # Handle VM reset/deletion
    if args.reset:
        reset_vm(conn, args.reset)
        conn.close()
        return

    # Use default ISO path if not specified
    iso_path = args.iso
    if not iso_path:
        default_iso = "vms/keystone-installer.iso"
        if os.path.exists(default_iso):
            iso_path = os.path.abspath(default_iso)
            print(f"✓ Using default ISO: {iso_path}")
        else:
            print(f"ℹ No ISO specified and {default_iso} not found")
            print(f"  Build ISO first with: ./bin/build-iso")
    elif iso_path:
        # Convert to absolute path if provided
        iso_path = os.path.abspath(iso_path)

    # VM configuration
    vm_dir = f"vms/{args.name}"
    disk_path = f"{vm_dir}/disk.qcow2"

    # Create the VM
    dom = create_uefi_secureboot_vm(
        conn,
        vm_name=args.name,
        memory_mb=args.memory,
        vcpus=args.vcpus,
        disk_path=disk_path,
        disk_size_gb=args.disk_size,
        iso_path=iso_path,
        ssh_port=args.ssh_port
    )

    # Start VM if requested
    if args.start:
        dom.create()
        print(f"✓ VM '{args.name}' started")

    # Print connection commands
    print_connection_commands(args.name, args.ssh_port)

    conn.close()


if __name__ == "__main__":
    main()
