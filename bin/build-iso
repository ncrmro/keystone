#!/usr/bin/env python3
"""
Keystone ISO Builder

A tool to build NixOS installer ISOs for x86_64 and aarch64 (Apple Silicon).
Supports remote builders for cross-compilation from macOS.
"""

import argparse
import os
import platform
import re
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

# ANSI colors
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
NC = "\033[0m"  # No Color


def print_color(color: str, message: str, file=sys.stdout):
    """Print a colored message."""
    print(f"{color}{message}{NC}", file=file)


def print_error(message: str):
    print_color(RED, message, file=sys.stderr)


def print_warning(message: str):
    print_color(YELLOW, message, file=sys.stderr)


def print_info(message: str):
    print_color(BLUE, message)


def print_success(message: str):
    print_color(GREEN, message)


def run_command(cmd: list[str], check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    """Run a command and optionally capture output."""
    if capture:
        return subprocess.run(cmd, check=check, capture_output=True, text=True)
    return subprocess.run(cmd, check=check)


def test_ssh_connection(host: str, identity_file: str | None = None) -> bool:
    """Test SSH connectivity to a host."""
    cmd = ["ssh", "-o", "BatchMode=yes", "-o", "ConnectTimeout=5"]
    if identity_file:
        cmd.extend(["-i", identity_file])
    cmd.extend([host, "echo", "SSH OK"])

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            # If debug mode is implicitly desired or we want to log why it failed:
            # We don't have access to 'args.debug' here easily without changing signature heavily,
            # but we can print error if it fails.
            pass 
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def check_remote_trust(host: str, identity_file: str | None = None) -> bool:
    """Check if the remote user is trusted by the Nix daemon."""
    # We need to determine the remote user. 
    # If host is "user@host", we can parse it.
    if "@" in host:
        user, hostname = host.split("@")
    else:
        # Defaults to current user, but for remote builds it's usually explicit.
        # If not, we can't easily guess without `ssh -G`.
        # For this script's usage, we can assume "user@host" format or try to get it from `whoami` on remote.
        user = "root" # Fallback, likely wrong if not root
        hostname = host
    
    cmd = ["ssh", "-o", "BatchMode=yes", "-o", "ConnectTimeout=5"]
    if identity_file:
        cmd.extend(["-i", identity_file])
    
    # Command to check trusted users. 
    # We use 'nix config show' (newer) or 'nix show-config' (older)
    # And we need to enable experimental features for the command to work on some versions
    check_cmd = "nix --extra-experimental-features nix-command config show trusted-users 2>/dev/null || nix show-config trusted-users 2>/dev/null || nix show-config | grep trusted-users"
    
    cmd.extend([host, check_cmd])

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )
        
        if result.returncode == 0:
            output = result.stdout.strip()
            # Output format: "trusted-users = root ubuntu" or just "root ubuntu" depending on command version
            # We check if our user is in there
            if user in output:
                return True
                
        return False
    except Exception:
        # If check fails (e.g. command not found), we can't be sure. 
        # But failing open might be better than blocking? 
        # Or failing closed to warn?
        # Let's assume false to prompt the user to check.
        return False

def check_binfmt(arch: str) -> bool:
    """Check if binfmt emulation is available for an architecture."""
    binfmt_path = Path(f"/proc/sys/fs/binfmt_misc/qemu-{arch}")
    return binfmt_path.exists()


def check_nix_remote_builder(arch: str) -> bool:
    """Check if nix has a remote builder configured for the architecture."""
    try:
        result = subprocess.run(
            ["nix", "show-config"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        return arch in result.stdout
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def parse_ssh_keys(ssh_key_input: str) -> list[str]:
    """Parse SSH keys from file path or direct string."""
    keys = []

    # Check if input looks like a file path
    if ssh_key_input.startswith(("/", "~", ".")):
        path = Path(ssh_key_input).expanduser()
        if not path.exists():
            print_error(f"Error: SSH keys file '{path}' not found")
            sys.exit(1)

        content = path.read_text()
        for line in content.splitlines():
            line = line.strip()
            if line and not line.startswith("#"):
                keys.append(line)

        if not any(k.startswith("ssh-") for k in keys):
            print_warning(f"Warning: No SSH keys found in '{path}'")
    else:
        # Direct SSH key string
        if not ssh_key_input.startswith("ssh-"):
            print_error("Error: SSH key string must start with 'ssh-'")
            print_warning("Example: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG... user@host")
            sys.exit(1)
        keys.append(ssh_key_input)

    return keys


def create_aarch64_flake(script_dir: Path, ssh_keys: list[str], enable_tui: bool = True) -> str:
    """Create a temporary flake.nix for aarch64-linux builds."""
    keys_nix = "[" + " ".join(f'"{k}"' for k in ssh_keys) + "]"
    tui_nix = "true" if enable_tui else "false"

    return f'''{{
  description = "Keystone ISO for Apple Silicon";

  inputs = {{
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    nixos-apple-silicon = {{
      url = "github:tpwrules/nixos-apple-silicon";
      inputs.nixpkgs.follows = "nixpkgs";
    }};
  }};

  outputs = {{ self, nixpkgs, nixos-apple-silicon }}: {{
    nixosConfigurations = {{
      keystoneIso = nixpkgs.lib.nixosSystem {{
        system = "aarch64-linux";
        modules = [
          "${{nixpkgs}}/nixos/modules/installer/cd-dvd/installation-cd-minimal.nix"
          nixos-apple-silicon.nixosModules.apple-silicon-support
          {script_dir}/modules/iso-installer-apple-silicon.nix
          {{
            _module.args.sshKeys = {keys_nix};
            _module.args.enableTui = {tui_nix};
          }}
        ];
      }};
    }};

    packages.aarch64-linux.default =
      self.nixosConfigurations.keystoneIso.config.system.build.isoImage;
  }};
}}
'''


def create_x86_64_flake(script_dir: Path, ssh_keys: list[str], arch: str, enable_tui: bool = True) -> str:
    """Create a temporary flake.nix for x86_64-linux builds."""
    keys_nix = "[" + " ".join(f'"{k}"' for k in ssh_keys) + "]"
    tui_nix = "true" if enable_tui else "false"

    return f'''{{
  description = "Keystone ISO with custom SSH keys";

  inputs = {{
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";
  }};

  outputs = {{ self, nixpkgs }}: {{
    nixosConfigurations = {{
      keystoneIso = nixpkgs.lib.nixosSystem {{
        system = "{arch}";
        modules = [
          "${{nixpkgs}}/nixos/modules/installer/cd-dvd/installation-cd-minimal.nix"
          {script_dir}/modules/iso-installer.nix
          {{
            _module.args.sshKeys = {keys_nix};
            _module.args.enableTui = {tui_nix};
            boot.kernelPackages = nixpkgs.lib.mkForce
              nixpkgs.legacyPackages.{arch}.linuxPackages_6_12;
          }}
        ];
      }};
    }};

    packages.{arch}.default =
      self.nixosConfigurations.keystoneIso.config.system.build.isoImage;
  }};
}}
'''


def build_nix_command(remote_builder: str | None, arch: str, builder_key: str | None = None) -> list[str]:
    """Build the nix command with appropriate flags."""
    cmd = ["nix", "build"]

    if remote_builder:
        # Parse builder spec: "user@host system"
        # The Asahi kernel requires "big-parallel" feature
        parts = remote_builder.split()
        host = parts[0]
        systems = parts[1] if len(parts) > 1 else "aarch64-linux"

        # Determine SSH key path - nix-daemon needs explicit path since it runs as root
        if builder_key:
            ssh_key = str(Path(builder_key).expanduser().resolve())
        else:
            # Try common SSH key locations
            for key_name in ["id_ed25519", "id_rsa"]:
                key_path = Path.home() / ".ssh" / key_name
                if key_path.exists():
                    ssh_key = str(key_path)
                    break
            else:
                ssh_key = None

        # Build URI with ssh-key query parameter (more reliable than space-separated format)
        # See: https://nix.dev/manual/nix/2.32/advanced-topics/distributed-builds
        if ssh_key:
            builder_uri = f"ssh-ng://{host}?ssh-key={ssh_key}"
        else:
            builder_uri = f"ssh-ng://{host}"

        # Full builder spec format: URI systems identityFile maxJobs speedFactor features
        # Using - for identityFile since we pass it via query param
        builder_spec = f"{builder_uri} {systems} - - 1 big-parallel"

        # Force remote builds only
        cmd.extend([
            "--max-jobs", "0",
            "--builders-use-substitutes",
            "--builders", builder_spec,
        ])
    elif arch == "aarch64-linux":
        # Limit parallelism for local aarch64 builds (Asahi kernel is heavy)
        cmd.extend(["-j4"])

    return cmd


def find_iso(output_dir: Path) -> Path | None:
    """Find the ISO file in the output directory."""
    iso_dir = output_dir / "iso"
    if iso_dir.exists():
        for f in iso_dir.iterdir():
            if f.suffix == ".iso":
                return f
    return None


def main():
    parser = argparse.ArgumentParser(
        description="Keystone ISO Builder",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    # Build x86_64 ISO with SSH key from file
    %(prog)s --ssh-key ~/.ssh/id_ed25519.pub

    # Build for Apple Silicon
    %(prog)s --ssh-key ~/.ssh/id_ed25519.pub --arch aarch64-linux

    # Build on macOS using remote builder
    %(prog)s --ssh-key ~/.ssh/id_ed25519.pub --arch aarch64-linux \\
        --builder "user@linux-host aarch64-linux"

REMOTE BUILDER:
    macOS cannot build Linux binaries natively. Use --builder to offload
    builds to a remote Linux machine with Nix installed.

    Format: "user@host arch1 arch2..."
    Example: --builder "nixbuilder@192.168.1.100 aarch64-linux"
""",
    )

    key_group = parser.add_mutually_exclusive_group(required=True)
    key_group.add_argument(
        "-k", "--ssh-key",
        help="SSH public key (file path or key string directly)",
    )
    key_group.add_argument(
        "--no-ssh-key",
        action="store_true",
        help="Build ISO without SSH keys (creates inaccessible installer!)",
    )

    parser.add_argument(
        "-a", "--arch",
        default="x86_64-linux",
        choices=["x86_64-linux", "aarch64-linux"],
        help="Target architecture (default: x86_64-linux)",
    )
    parser.add_argument(
        "-b", "--builder",
        help='Remote builder for aarch64-linux (format: "user@host arch")',
    )
    parser.add_argument(
        "--builder-key",
        help="SSH private key for remote builder (default: ~/.ssh/id_ed25519)",
    )
    parser.add_argument(
        "-o", "--output",
        default="result",
        help="Output directory (default: result)",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug output",
    )
    parser.add_argument(
        "--no-tui",
        action="store_true",
        help="Disable TUI installer (headless/SSH only)",
    )

    args = parser.parse_args()

    # Get script directory
    script_dir = Path(__file__).resolve().parent.parent
    output_dir = Path(args.output)
    
    # Determine TUI status
    enable_tui = not args.no_tui

    # Validate remote builder
    if args.builder:
        # Normalize builder string to handle spacing issues (e.g. "user @ host")
        args.builder = re.sub(r'\s*@\s*', '@', args.builder)

        if args.arch != "aarch64-linux":
            print_warning("âš ï¸  --builder is only used for aarch64-linux builds, ignoring")
            args.builder = None
        elif "@" not in args.builder.split()[0]:
            print_error(f"Error: Invalid builder format '{args.builder}'")
            print_warning("Expected format: user@host arch (e.g., 'user@192.168.1.100 aarch64-linux')")
            sys.exit(1)

    # Check cross-compilation capability
    host_arch = platform.machine()
    host_os = platform.system()

    if args.arch == "aarch64-linux":
        if args.builder:
            # Test SSH connection to builder
            builder_host = args.builder.split()[0]
            print_info(f"â„¹ï¸  Using remote builder: {args.builder}")
            print_info(f"   Testing SSH connection to {builder_host}...")

            if not test_ssh_connection(builder_host, args.builder_key):
                print_error(f"Error: Cannot connect to remote builder '{builder_host}'")
                print_warning("Make sure:")
                print_warning("  1. SSH key-based auth is set up")
                print_warning("  2. The host is reachable")
                if args.builder_key:
                    print_warning(f"  3. The key '{args.builder_key}' is correct and has correct permissions")
                sys.exit(1)

            print_success("   âœ“ SSH connection successful")

            # Check if remote user is trusted
            # This is required for the remote builder to accept unsigned paths (like our source)
            # from our local machine.
            print_info(f"   Checking if user is trusted on {builder_host}...")
            if not check_remote_trust(builder_host, args.builder_key):
                print_warning(f"âš ï¸  Remote user is NOT trusted by the Nix daemon on {builder_host}.")
                print_warning("   This will cause 'lacks a signature by a trusted key' errors when copying sources.")
                print()

                # Propose fix
                remote_user = builder_host.split('@')[0] if '@' in builder_host else 'user'
                fix_cmd = f"echo 'trusted-users = root {remote_user}' | sudo tee -a /etc/nix/nix.conf && sudo systemctl restart nix-daemon"

                print_info("   Proposed fix (runs on remote machine):")
                print_info(f"   {fix_cmd}")
                print()

                response = input("   Apply this fix now? [Y/n] ").strip().lower()
                if response in ["", "y"]:
                    # Attempt to apply fix
                    ssh_cmd = ["ssh", "-o", "BatchMode=yes"]
                    if args.builder_key:
                        ssh_cmd.extend(["-i", args.builder_key])
                    ssh_cmd.extend([builder_host, fix_cmd])

                    try:
                        print_info("   Applying fix...")
                        subprocess.run(ssh_cmd, check=True)
                        print_success("   âœ… Fix applied successfully!")
                    except subprocess.CalledProcessError:
                        print_error("   âŒ Failed to apply fix automatically.")
                        print_info("   Please run the command manually on the remote machine.")
                        # Proceed anyway if user wants
                else:
                    print_warning("   Continuing without applying fix. Build will likely fail.")
        elif host_os == "Darwin":
            print_error("Error: Cannot build aarch64-linux on macOS without a remote builder")
            print()
            print_warning("macOS cannot build Linux binaries natively. Options:")
            print()
            print("  1. Use --builder to specify a remote Linux machine:")
            print_info(f"     {sys.argv[0]} --builder 'user@linux-host aarch64-linux' --arch aarch64-linux ...")
            print()
            print("  2. Use OrbStack (lightweight Linux VM for Mac):")
            print_info("     brew install orbstack && orb create nixos")
            print()
            print("  3. Use GitHub Actions or Codespaces")
            sys.exit(1)

        elif host_arch == "x86_64":
            if check_binfmt("aarch64"):
                print_info("â„¹ï¸  Cross-compiling aarch64-linux on x86_64 (using binfmt emulation)")
            elif check_nix_remote_builder("aarch64-linux"):
                print_info("â„¹ï¸  Cross-compiling aarch64-linux on x86_64 (using configured remote builder)")
            else:
                print_warning("âš ï¸  Cross-compiling aarch64-linux on x86_64")
                print_warning("   No binfmt emulation or remote builder detected.")
                print_warning("   Build may fail or be slow. To enable fast cross-compilation:")
                print()
                print_info("   # Add to your NixOS configuration:")
                print_info('   boot.binfmt.emulatedSystems = [ "aarch64-linux" ];')
                print()
                print_warning("   Then rebuild: sudo nixos-rebuild switch")
                print()
                print_warning("   Or use --builder to specify a remote aarch64-linux machine")
                print()

                response = input("Continue anyway? [y/N] ").strip().lower()
                if response != "y":
                    sys.exit(1)

    elif args.arch == "x86_64-linux" and host_arch == "aarch64":
        if check_binfmt("x86_64"):
            print_info("â„¹ï¸  Cross-compiling x86_64-linux on aarch64 (using binfmt emulation)")
        else:
            print_warning("âš ï¸  Cross-compiling x86_64-linux on aarch64 - may require remote builder")

    # Warn if building without SSH keys
    if args.no_ssh_key:
        print_warning("âš ï¸  Building ISO without SSH keys - this will create an inaccessible installer!")
        print_warning("âš ï¸  This is only recommended for testing purposes.")
        print()

    # Parse SSH keys
    ssh_keys = []
    if args.ssh_key:
        ssh_keys = parse_ssh_keys(args.ssh_key)
        print_info(f"ğŸ“‹ Using SSH keys: {len(ssh_keys)} key(s)")

    print_info("ğŸ”¨ Building Keystone ISO...")
    if args.no_tui:
        print_info("â„¹ï¸  TUI installer disabled (headless mode)")

    # Build the ISO
    if ssh_keys:
        # Create temporary flake with SSH keys
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)

            print_info("ğŸ”‘ Processing SSH keys...")

            if args.arch == "aarch64-linux":
                flake_content = create_aarch64_flake(script_dir, ssh_keys, enable_tui)
            else:
                flake_content = create_x86_64_flake(script_dir, ssh_keys, args.arch, enable_tui)

            flake_path = temp_path / "flake.nix"
            flake_path.write_text(flake_content)

            print_info(f"ğŸš€ Building {args.arch} ISO with SSH keys...")

            # Build nix command
            nix_cmd = build_nix_command(args.builder, args.arch, args.builder_key)
            nix_cmd.extend([
                f".#packages.{args.arch}.default",
                "--impure",
                "--out-link", str(script_dir / args.output),
            ])

            if args.debug:
                nix_cmd.append("--show-trace")
                nix_cmd.append("--verbose")
                print_info(f"DEBUG: Command: {' '.join(nix_cmd)}")

            try:
                subprocess.run(nix_cmd, check=True, cwd=temp_path)
            except subprocess.CalledProcessError as e:
                print_error(f"âŒ Build failed with exit code {e.returncode}")
                sys.exit(1)
    else:
        # Build without SSH keys
        if args.arch == "x86_64-linux":
            print_info(f"ğŸš€ Building {args.arch} ISO without SSH keys...")
            nix_cmd = ["nix", "build", ".#iso", "--out-link", str(output_dir)]

            try:
                subprocess.run(nix_cmd, check=True, cwd=script_dir)
            except subprocess.CalledProcessError as e:
                print_error(f"âŒ Build failed with exit code {e.returncode}")
                sys.exit(1)
        else:
            # aarch64-linux without SSH keys
            print_info(f"ğŸš€ Building {args.arch} ISO without SSH keys (Apple Silicon)...")

            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                flake_content = create_aarch64_flake(script_dir, [], enable_tui)
                flake_path = temp_path / "flake.nix"
                flake_path.write_text(flake_content)

                nix_cmd = build_nix_command(args.builder, args.arch, args.builder_key)
                nix_cmd.extend([
                    f".#packages.{args.arch}.default",
                    "--impure",
                    "--out-link", str(script_dir / args.output),
                ])

                if args.debug:
                    nix_cmd.append("--show-trace")
                    nix_cmd.append("--verbose")
                    print_info(f"DEBUG: Command: {' '.join(nix_cmd)}")

                try:
                    subprocess.run(nix_cmd, check=True, cwd=temp_path)
                except subprocess.CalledProcessError as e:
                    print_error(f"âŒ Build failed with exit code {e.returncode}")
                    sys.exit(1)

    # Check if build was successful
    output_path = script_dir / args.output
    if output_path.is_symlink() and output_path.exists():
        iso_file = find_iso(output_path)

        if iso_file:
            iso_size = iso_file.stat().st_size
            iso_size_human = f"{iso_size / (1024**3):.1f}G" if iso_size > 1024**3 else f"{iso_size / (1024**2):.0f}M"

            print_success("âœ… ISO built successfully!")
            print_success(f"ğŸ“ Location: {iso_file}")
            print_success(f"ğŸ“„ Filename: {iso_file.name}")
            print_success(f"ğŸ“¦ Size: {iso_size_human}")

            # Link ISO to vms directory
            vms_iso = script_dir / "vms" / "keystone-installer.iso"
            if vms_iso.exists() or vms_iso.is_symlink():
                vms_iso.unlink()

            vms_iso.parent.mkdir(parents=True, exist_ok=True)
            vms_iso.symlink_to(f"../{args.output}/iso/{iso_file.name}")
            print_success(f"ğŸ”— Linked to: {vms_iso}")

            print()
            print_info("ğŸ”¥ To write to USB:")
            print_info(f'   sudo dd if="{iso_file}" of=/dev/sdX bs=4M status=progress')
            print_warning("   (Replace /dev/sdX with your USB device)")
        else:
            print_error("âŒ Build completed but ISO file not found")
            sys.exit(1)
    else:
        print_error(f"âŒ Build failed - {output_path} does not exist")
        sys.exit(1)


if __name__ == "__main__":
    main()
